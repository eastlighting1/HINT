import time
from pathlib import Path
from contextlib import contextmanager
from typing import Optional, ContextManager

from loguru import logger
from rich.console import Console
from ..foundation.interfaces import TelemetryObserver

class RichTelemetryObserver(TelemetryObserver):
    """
    Telemetry implementation using Loguru for files and Rich for the terminal.

    This class ensures separation of concerns:
    - Loguru writes strictly to the file generated by Hydra (via the current working directory).
    - Rich writes strictly to the terminal (stdout).

    Args:
        log_filename: Name of the log file to be created in the current directory.
    """
    def __init__(self, log_filename: str = "train.log"):
        self.console = Console()
        
        # Configure Loguru: remove default stderr handler and add file sink
        logger.remove()
        log_path = Path.cwd() / log_filename
        logger.add(log_path, format="{time} {level} {message}", level="INFO")
        
        self.console.print(f"[bold green]Telemetry initialized. Log file:[/bold green] {log_path}")

    def log(self, level: str, message: str) -> None:
        """
        Log a message to both the file and the terminal.

        Args:
            level: Severity level.
            message: Content of the log.
        """
        # File logging via Loguru
        if level == "INFO":
            logger.info(message)
        elif level == "WARNING":
            logger.warning(message)
        elif level == "ERROR":
            logger.error(message)
        else:
            logger.debug(message)

        # Terminal logging via Rich
        style_map = {
            "INFO": "green",
            "WARNING": "yellow",
            "ERROR": "bold red",
            "DEBUG": "dim"
        }
        style = style_map.get(level, "white")
        self.console.print(f"[{style}][{level}][/] {message}")

    def track_metric(self, name: str, value: float, step: Optional[int] = None) -> None:
        """
        Display a metric on the terminal.

        Args:
            name: Metric name.
            value: Metric value.
            step: Current step index.
        """
        step_str = f"[step={step}]" if step is not None else ""
        self.console.print(f"    >>> Metric {step_str} [cyan]{name}[/]: {value:.4f}")

    @contextmanager
    def trace(self, span_name: str) -> ContextManager:
        """
        Trace the duration of a block. Logs if it exceeds a threshold.

        Args:
            span_name: Name of the operation.
        """
        start = time.time()
        yield
        duration = time.time() - start
        if duration > 1.0:
            logger.debug(f"Span '{span_name}' took {duration:.2f}s")